#!/bin/sh
#
#  ciao-env
#
#  Setup environment for shells
#
#  Copyright (C) 2017 Ciao Developer Team
#

# Physical directory where the script is located
_base=$(e=$0;while test -L "$e";do d=$(dirname "$e");e=$(readlink "$e");\
        cd "$d";done;cd "$(dirname "$e")";pwd -P)

# ---------------------------------------------------------------------------
# Add paths
#
# This adds to PATH,MANPATH,INFOPATH the paths corresponding to the
# bin/ and doc/ directories for detected CIAOROOT and CIAOPATH. Paths
# are added even if directories do not exist yet (e.g.,
# ~/.ciao/build/bin is added even if the user has not installed any
# bundle via 'ciao get').

# Return path:old2, where old2 is old where path is removed, or just
# path if old is empty
concat_nodup() { # path old
    if [ x"$2" = x"" ]; then
	printf "%s" "$1"
    else
	printf "%s" "$1":$(printf "%s" "$2" | sed -e s:'\:'"$1"::g)
    fi
}

# Add a binary path
add_bindir() { # dir
    PATH=$(concat_nodup "$1" "$PATH")
}
# Add a documentation path (for MANPATH and INFOPATH)
add_docdir() { # dir
    if [ "${INFOPATH:-0}" = "0" ]; then
	INFOPATH=/usr/info:/usr/share/info:/usr/local/info
    fi
    MANPATH=$(concat_nodup "$1" "$MANPATH")
    INFOPATH=$(concat_nodup "$1" "$INFOPATH")
}

# Add additional paths from CIAOPATH
get_paths() {
    if [ x"$CIAOPATH" = x"" ]; then
	curr_ciaopath=$HOME/.ciao # Use default (even if it does not exist)
    else
	curr_ciaopath=$CIAOPATH
    fi
    IFS=: get_paths_
}
get_paths_() {
    revpath=
    for i in $curr_ciaopath; do # reverse
	revpath=$i':'$revpath
    done
    revpath=$(printf "%s" "$revpath" | sed -e s:'\:$'::g) # remove last :
    get_paths__ $revpath
}
get_paths__() {
    unset IFS
    for i in "$@"; do
	add_bindir "$i"/build/bin
	add_docdir "$i"/build/doc
    done
}

# ---------------------------------------------------------------------------
# Generate commands that change the environment

env_help_sh() {
    cat <<EOF
#
# Run this command to setup your environment:
#   eval "\$(ciao-env --sh)"
EOF
}
env_help_csh() {
    # NOTE: tcsh/csh cannot eval comments. The trick to write
    #   something that looks like a comment in tcsh is using the ':'
    #   command (which requires quoting!): E.g.,
    #     : 'this is a comment';
    #   That is not valid in csh. So we will just echo and redirect to
    #   /dev/null.
    cat <<EOF
echo '' > /dev/null;
echo 'Run this command to setup your environment:' > /dev/null;
echo '  eval \`ciao-env --csh\`' > /dev/null;
EOF
}

env_sh() {
    cat <<EOF
export PATH="$PATH"
export MANPATH="$MANPATH"
export INFOPATH="$INFOPATH"
EOF
}
env_csh() {
    cat <<EOF
setenv PATH "$PATH";
setenv MANPATH "$MANPATH";
setenv INFOPATH "$INFOPATH";
EOF
}

env_reloc_sh() {
    cat <<EOF
export CIAOENGINE="$CIAOENGINE"
export CIAOHDIR="$CIAOHDIR"
export CIAOLIB="$CIAOLIB"
EOF
}
env_reloc_csh() {
    cat <<EOF
setenv CIAOENGINE "$CIAOENGINE";
setenv CIAOHDIR "$CIAOHDIR";
setenv CIAOLIB "$CIAOLIB";
EOF
}

env_gen() { # tgtshell
    tgtshell=$1
    # Use DOTprofile
    . "$_base"/DOTprofile

    get_paths
    # DOTprofile contains info for relocatable
    reloc=no
    if [ x"${CIAOENGINE}" != x"" ]; then
	reloc=yes
    fi

    # Print commands to change environment
    env_$tgtshell
    if [ $reloc = yes ]; then
	env_reloc_$tgtshell
    fi
    env_help_$tgtshell
}

# ---------------------------------------------------------------------------
# Parse options and run

tgtshell=sh
while [ $# -gt 0 ]; do
    case "$1" in
	--sh|--bash) tgtshell=sh ;;
	--csh|--tcsh) tgtshell=csh ;;
	*) 
	    cat <<EOF 
ERROR: Unrecognized option $1
EOF
	    exit 1
	    ;;
    esac
    shift
done
env_gen $tgtshell
